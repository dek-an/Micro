#include <HAL.h>
#include <EERTOS.h>



// Прототипы задач ============================================================

// Global Variables


u08 i=0;



//RTOS Interrupt
ISR(RTOS_ISR)
{
sei();
TimerService();						// Прерывание ядра диспетчера
}
//..........................................................................


ISR(TIMER2_OVF_vect)
{
UDR = i;
i++;
}


//============================================================================
//Область задач
//============================================================================
void InitASS_Timer(void)
{
if(ASSR & (1<<AS2))	//Если это второй вход то
	{	
	if (ASSR & (1<<TCN2UB | 1<<OCR2UB | TCR2UB) ) 	// проверяем есть ли хоть один бит флаговый
		{
		SetTask(InitASS_Timer);						// Если есть, то отправляем на повторный цикл ожидания
		}
	else											// Если все чисто, то можно запускать прерывания
		{
		TIFR  |= 1<<OCF2 | 1<< TOV2;				// Сбрасываем флаги прерываний, на всякий случай.
		TIMSK |= 1<< TOIE2;							// Разрешаем прерывание по переполнению
		return;
		}

	}

TIMSK &=~(1<<OCIE2 | 1<< TOIE2);		// Запрещаем прерывания таймера 2
ASSR  = 1<<AS2;							// Включаем асинхронный режим
TCNT2 = 0;
TCCR2 = 5<<CS20; 						// Предделитель на 128 на 32768 даст 256 тиков в секунду
										// Что даст 1 прерывание в секунду.				
SetTask(InitASS_Timer);					// Прогоняем через диспетчер, чтобы зайти снова. 
}

//==============================================================================
int main(void)
{
InitAll();			// Инициализируем периферию
InitRTOS();			// Инициализируем ядро
RunRTOS();			// Старт ядра. 

UDR = 'R';

SetTimerTask(InitASS_Timer,1000);

while(1) 		// Главный цикл диспетчера
{
wdt_reset();	// Сброс собачьего таймера
TaskManager();	// Вызов диспетчера
}

return 0;
}



