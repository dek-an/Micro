			.include "m16def.inc"	; Используем ATMega8
			.include "define.asm"	; Наши все определения переменных тут
			.include "macro.asm"	; Все макросы у нас тут

			.include "WH\lcd4_macro.inc"
			.include "kernel_macro.asm"

;============SSEG=============================================================
			.DSEG
Mode:		.byte					1		; Переменная режима отображения
			.equ	m_Normal	=0			; Показ логотипа
			.equ	m_Terminal	=1			; Показ минитерминала
			.equ	m_ADC		=2			; Показ данных АЦП
			.equ	m_Button	=3			; Показ имени нажатой кнопки

ADC_Data:	.byte					1		; Тут складируются данные АЦП
ADC_OLD:	.byte					1		; Тут хранится предыдущее значение данных АЦП

ADC_DIG0:	.byte					1		; В этих трех ячейках хранятся ASCII коды
ADC_DIG1:	.byte					1		; данных из АЦП, подготовленные к выводу на экран
ADC_DIG2:	.byte					1		; 

Pressed_B:	.byte					1		; В этой переменной хранится имя последней нажатой клавиши

UDR_I:		.byte					1		; Принятый байт 

BreakLoop:	.byte					3		; Байты выхода из цикла дисплея?

RX_CURR:	.byte					1		; Положение курсора терминала

TextLine1:	.byte					DWIDTH	; Видеопамять. Длина ее зависит от ширины экрана
TextLine2:	.byte					DWIDTH	; Ширина указана в lcd4_macro.inc, в самом конце.

PWM_L_V:	.byte					1
PWM_L_V2:	.byte					1


;UART_Text:	.byte					10		; Буффер уарта. Не используется.


; Очереди операционной системы
			.equ TaskQueueSize 		= 20				; Размер очереди задач
TaskQueue: 	.byte					TaskQueueSize 		; Адрес очереди задач в SRAM
			
			.equ TimersPoolSize 	= 20				; Количество таймеров
TimersPool:	.byte 					TimersPoolSize*3	; Адреса информации о таймерах (очередь)


;===========CSEG==============================================================
			.include "vectors.asm"	; Все вектора прерываний спрятаны в этом файле

			.ORG	INT_VECTORS_SIZE		; Конец таблицы прерываний


;=============================================================================!
; Interrupts procs ===========================================================!
;=============================================================================!
; Output Compare 2 interrupt 
; Main Timer Service - Служба Таймеров Ядра РТОС - Обработчик прерывания
OutComp2Int:
			SBI		PZ_P,PZ
			TimerService				; Служба таймера RTOS 
			CBI		PZ_P,PZ
			RETI						; выходим из прерывания
;.............................................................................

; Прерывание от АЦП. Мы тут ничего особого не делаем, только складываем данные
; в ячейку памяти ОЗУ
ADC_INT:	PUSH	OSRG				; Сохраняем рабчий регистр
	
			IN		OSRG,ADCH			; Берем данные из АЦП
			STS		ADC_Data,OSRG		; Перекладываем их в ОЗУ

			POP		OSRG				; Восстанавливаем рабочий регистр
			RETI						; Выход из прерывания


;.............................................................................

;Прерывания от пришедшего байта в UART
RX_OK:		PUSH 	OSRG
			IN 		OSRG,SREG			; Save Sreg
			PUSH 	OSRG

			IN		OSRG,UDR
			STS		UDR_I,OSRG

			SetTask			TS_Terminal

			POP 	OSRG				; Восстанавливаем регистры
			OUT 	SREG,OSRG			; 
			POP 	OSRG
			RETI						; Выходим из прерывания


;=============================================================================!
; Main code ==================================================================!
;=============================================================================!
Reset:		OUTI 	SPL,low(RAMEND) 		; Первым делом инициализируем стек
			OUTI	SPH,High(RAMEND)								

			.include "init.asm"				; Все инициализации тут.


; Запуск фоновых процессов
Background:	RCALL	ScanADC				; Сканирование АЦП
			RCALL	Send				; Отсыл байт в UART 
			RCALL	Fill				; Перерисовка экрана
			RCALL	SetDefMode			; Сброс режима отображения в дефолтное состояние спустя какое то время
			RCALL	CheckADC			; Проверка показаний АЦП на изменение
			RCALL	ScanButton			; Сканирование кнопок.
			RCALL	PWM_Light			; Плавная моргалка
			RCALL	PWM_Light2			; Плавная моргалка

Main:		SEI								; Разрешаем прерывания.

			wdr								; Reset Watch DOG (Если не "погладить" "собаку". то она устроит конец света в виде reset для процессора)
			rcall 	ProcessTaskQueue		; Обработка очереди процессов
			rcall 	Idle					; Простой Ядра
											
			RJMP 	Main					; Основной цикл микроядра РТОС

;=============================================================================
;Tasks
;=============================================================================
Idle:		RET		; Простой ядра. Не используется

;-----------------------------------------------------------------------------
; Задача сканирования АЦП. Раз в 10мс запускается АЦП и берет значение.
ScanADC:	SetTimerTask	TS_ScanADC,10	; Самозацикливаем задачу через диспетчер таймера

			OUTI	ADCSRA,(1<<ADEN)|(1<<ADIE)|(1<<ADSC)|(1<<ADATE)|(3<<ADPS0)	; Запускаем ОДНОКРАТНОЕ Преобразование
			RET								; На этом задача завершена

;-----------------------------------------------------------------------------
; Задача отсылки данных через терминал. Раз в 50мс шлет байт который считало АЦП
Send:		SetTimerTask	TS_Send,50		; Самозацикливаем задачу через диспетчер таймеров

			LDS		OSRG,ADC_Data			; Загрузить байт из переменной ADC_DATA
			OUT		UDR,OSRG				; Отправить его через USART 
			RET
;-----------------------------------------------------------------------------
; Задача обновления экрана дисплея. Дисплей обновляется 5 раз в секунду, каждые 200мс
; данные берутся из видеопамяти и фоном записываются в контроллер HD44780
Fill:		SetTimerTask	TS_Fill,200		; Самозацикливание задачи через диспетчер таймеров

			LCDCLR							; Очистка дисплея

			LDZ		TextLine1				; Взять в индекс Z адрес начала видеопамяти
			
			LDI		Counter,DWIDTH			; Загрузить счетчик числом символов в строке

Filling1:	LD		OSRG,Z+			; Брать последовательно байты из видеопамяти, увеличивая индекс Z
			RCALL	DATA_WR			; И передавать их дисплею

			DEC		Counter			; Уменьшить счетчик. 
			BRNE	Filling1		; Пока не будет 0 (строка не кончилась) - повторять

			LCD_COORD 0,1			; Как кончится строка - перевести строку в дисплее

			LDI		Counter,DWIDTH	; Опять загрузить длинной строки

Filling2:	LD		OSRG,Z+			; Адрес второй строки видеопамяти указывать не надо - они идут друг за другом 
			RCALL	DATA_WR			; И таким же макаром залить вторую строку из видеопамяти

			DEC		Counter			; Уменьшаем счетчик
			BRNE	Filling2		; Если строка не кончилась - продолжаем.
	
			RET
;-----------------------------------------------------------------------------
; Это функция рисования в видеопамять. Работает в зависимости от режима отображения
; Разбита на секции f_Button, f_Normal, f_Terminal, f_ADC по секции на режим. Выход из 
; задачи DRAW по RET в конце каждой секции.

Draw:		LDS		OSRG,Mode			; Берем текущее значение режима
			CPI		OSRG,m_Normal		; И определяем какое из
			BREQ	f_Normal			; Если Нормальный режим - переходим к нему

			CPI		OSRG,m_Terminal		; Если термниальный - то в секцию терминала
			BREQ	f_Terminal
			
			CPI		OSRG,m_ADC			; Аналогично, но в секцию АЦП
			BREQ	f_ADC
;..............................................................................
										; Если ничего другого - значит режим кнопок
f_Button:	LDI		Counter,DWIDTH		; Берем в счетчик ширину экрана
			LDZ		t_Button1*2			; Берем из Флеша первую строку режима Кнопок (там надпись "Нажата кнопка")
			LDY		TextLine1			; Загружаем в индекс У адрес первой строки видеопамяти
			RCALL	CopySTR				; И просто копируем ее в видеопамять напрямую

			LDS		OSRG,Pressed_B		; Потом берем значение нажатой кнопки (его внесет сюда задача сканирования клавиш)
			STS		TextLine2,OSRG		; И грузим его в первое место второй строки видеопамяти

			LDI		Counter,DWIDTH-1	; Теперь копируем из флеша сопроводительный текст. Он уже на байт короче, т.к. один
			LDZ		t_Button2*2			; байт мы только что нарисовали. Тут текст "-Номер кнопки"
			LDY		TextLine2+1
			RCALL	CopySTR

					
			RET							; Задача выполнена - выход в диспетчер
;..............................................................................
; Нормальный режим. В этом режиме. На экран выводится логтип платы. Просто берется как есть из флеша

f_Normal:	LDI		Counter,DWIDTH		; Скопировать в первую строку видеопамяти надпись "Pinboard v1.0"
			LDZ		t_Normal1*2
			LDY		TextLine1
			RCALL	CopySTR

			LDI		Counter,DWIDTH		; Скопировать во вторую строку видеопамяти надпись "by DI HALT 2009"
			LDZ		t_Normal2*2			; Строки эти располагаются в конце программы. 
			LDY		TextLine2
			RCALL	CopySTR
	
			RET
;.............................................................................
; Отображение терминала. Тут мы копируем из флеша в видеопамять только первую строку. Вторую
; строку нам нарисует обработчик прерывания от UART
f_Terminal: LDI		Counter,DWIDTH		; 
			LDZ		t_Terminal*2
			LDY		TextLine1
			RCALL	CopySTR
	
			RET
;.............................................................................
; Отображение режима АЦП. 
f_ADC:		LDI		Counter,DWIDTH		; Вначале берем значение ширины видеопамяти
			LDZ		t_ADC1*2			; Потом берем из флеша первую строку и тупо копируем
			LDY		TextLine1			; Ее в первую строку видеопамяти.
			RCALL	CopySTR
			
			LDS		OSRG,ADC_DIG2		; Во вторую строку мы вначале вписываем значения цифр
			STS		TextLine2,OSRG		; которые сформирует нам задача Convert 

			LDS		OSRG,ADC_DIG1		; Это величина снятая с АЦП. Обрати внимание, что байты
			STS		TextLine2+1,OSRG	; Заносятся просто смещением от начала второй строки видеопамяти
			
			LDS		OSRG,ADC_DIG0
			STS		TextLine2+2,OSRG

			LDI		Counter,DWIDTH-3	; А потом, забиваем наш статичный текст. Строка "- значение"
			LDZ		t_ADC2*2			; Т.к. три символа мы уже написали, то счетчик сразу уменьшим на 3
			LDY		TextLine2+3
			RCALL	CopySTR
			

EX_F:		RET							; Выход из задачи

CopySTR:	LPM		OSRG,Z+				; Процедура копирования из флеша в ОЗУ
			ST		Y+,OSRG				; Берет байт по индексу Z и грузит его в ячейки
			DEC		Counter				; По индексу Y. При этом автоматом инкрементируется индекс
			BRNE	CopySTR				; И вручную счетчик байтов в регистре Counter 
			RET

;-----------------------------------------------------------------------------
; ЗАдача сброса в дефолт спустя 5 секунд бездействия
SetDefMode:	SetTimerTask	TS_SetDefMode,5000 		; Самозацикливание задачи через диспетчер таймеров
			STSI	Mode,0							; Сброс режима в 0 - нормальный режим, показ заставки
			SetTask	TS_Draw							; Постановка на конвеер задачи перерисовки экрана
			RET
;-----------------------------------------------------------------------------
; Задача проверки состояния значений АЦП - не изменились ли?
CheckADC:	SetTimerTask	TS_CheckADC,100		; Вначале самозациклимся на 100мс

			LDS		OSRG,ADC_OLD				; Берем предыдущее значение АЦП
			LDS		ACC,ADC_DATA				; Берем последнее значение АЦП

			ANDI	ACC,0b11110000				; Отрезаем вечно меняющиеся младшие биты. Нам нужны только крупные изменения
			STS		ADC_OLD,ACC					; И текущее обрезанное значение записываем в старое значение

			CP		ACC,OSRG					; Сравниваем текущее значение с заранее взятым старым.

			BREQ	EX_CA						; Если значение не изменилось, то выходим.	

			SetTask			TS_Convert			; А если изменилось, то запускаем задачу конвертации показаний АЦП

EX_CA:		RET
;-----------------------------------------------------------------------------
; Эта задача берет байт показаний АЦП и превращает его в три байта ASCII кодов пригодных для вывода на дисплей
Convert:	LDS		R16,ADC_DATA		; Берем то самое значение

			RCALL	Hex2Ascii			; Вызываем функцию конвертации (она в файле Math\hex2ascii.asm)
			
			STS		ADC_DIG0,R16		; И результат нычим в переменные разрядов, которые потом загребет
			STS		ADC_DIG1,R17		; задача DRAW
			STS		ADC_DIG2,R18

			STSI	Mode,m_ADC			; Попутно обьявим что на ближайшие 2секунды у нас режим АЦП

			SetTimerTask	TS_SetDefMode,2000	; отложим сброс в дефолтный режим
			SetTask			TS_Draw				; И вызовем через диспетчер обновление видеопамяти

			RET
;-----------------------------------------------------------------------------
; Тут все просто - сканируется клавиатура 10 раз в секунду, каждые 100мс
ScanButton:	SetTimerTask	TS_ScanButton,100		; Задача естественно зациклена через диспетчер таймеров
			CLR		OSRG							; Сбрасываем рабочий регистр

			SBIS	BTA_N,BTA						; И проверяем биты кнопок
			LDI		OSRG,'3'						; Если нажата кнопка, то записываем в OSRG

			SBIS	BTB_N,BTB
			LDI		OSRG,'2'

			SBIS	BTC_N,BTC
			LDI		OSRG,'1'


			CPI		OSRG,0		; Если кнопка ни одна не нажата, то на выходе в OSRG 0
			BREQ	SB_EX		; Грустно выходим					

			STS		Pressed_B,OSRG		; А если нажата, то сохраняем ее в ОЗУ
			STSI	Mode,m_Button		; Ставим режим "Клавиатура"
			
			SetTimerTask	TS_SetDefMode,2000	; Отменяем сброс в дефолт на 2секунды
			SetTask			TS_Draw				; Перерисовываем видеопамять.

SB_EX:		RET									; Выход из задачи
;-----------------------------------------------------------------------------
; Обработка терминала.
Terminal:	LDS		Counter,RX_CURR		; Берем в Каунтер текущее значение положения курсора в видеопамяти
			CPI		Counter,DWIDTH		; Сравниваем с краем видеопамяти
			BREQ	RX_OVF				; Если переполнение то идем исправлять его

Load_T:		LDZ		TextLine2			; Загружаем в Z адрес второй строки видеопамяти

			ADD		ZL,Counter			; Складываем его с курсором таким образом
			ADC		ZH,Zero				; вычисляем в какое место видеопамяти писать символ
	
			INC		Counter				; Увеличиваем (сдвигаем курсор)
			STS		RX_CURR,Counter		; И сохраняем его где был

			LDS		OSRG,UDR_I			; Берем, Наконец то, данные пришедшие  из UART

			ST		Z,OSRG				; Сохраняем их в видео памяти где курсор.

			STSI	Mode,m_Terminal		; Выставляем режим "терминал", записав в переменную значение

			SetTask			TS_Draw				; Ставим в очередь задачу на перерисовку экрана
			SetTimerTask	TS_SetDefMode,5000	; Откладываем на 5сек сброс режима в Нормал.

			RET									

RX_OVF:		CLR		Counter				; Сбрасываем счетчик (курсор)
			RJMP	Load_T				; Возвращаемся к печати в видеопамять






PWM_Light:	LDS		ACC,PWM_L_V
			
			CPI 	ACC,-1
			BREQ	ON_TOP

			CPI		ACC,1
			BREQ	ON_BOTTOM


NEX:		ADD		OSRG,ACC
			OUT		OCR1AL,OSRG

			SetTimerTask TS_PWM_Light,5
			RET


ON_TOP:		LDI		ACC,1
			IN		OSRG,OCR1AL
			CPI		OSRG,255
			BRNE	NEX

			STS		PWM_L_V,ACC
			LDI		ACC,-1
			RJMP	NEX

ON_BOTTOM:	LDI		ACC,-1
			IN		OSRG,OCR1AL
			CPI		OSRG,0
			BRNE	NEX

			STS		PWM_L_V,ACC
			LDI		ACC,1
			RJMP	NEX

;------------------------------------------------------
PWM_Light2:	LDS		ACC,PWM_L_V2
			
			CPI 	ACC,-1
			BREQ	ON_TOP2

			CPI		ACC,1
			BREQ	ON_BOTTOM2


NEX2:		ADD		OSRG,ACC
			OUT		OCR1BL,OSRG

			SetTimerTask TS_PWM_Light2,5
			RET


ON_TOP2:	LDI		ACC,1
			IN		OSRG,OCR1BL
			CPI		OSRG,255
			BRNE	NEX2

			STS		PWM_L_V2,ACC
			LDI		ACC,-1
			RJMP	NEX2

ON_BOTTOM2:	LDI		ACC,-1
			IN		OSRG,OCR1BL
			CPI		OSRG,0
			BRNE	NEX2

			STS		PWM_L_V2,ACC
			LDI		ACC,1
			RJMP	NEX2


;=============================================================================
; RTOS Here
;=============================================================================
; Это область определения адресов и индексов задач. Порядок должен быть одинаковым, от этого
; критично зависит работа ОС

			.include "kernel_def.asm"	; Подключаем настройки ядра
			.include "kernel.asm"		; Подклчюаем ядро ОС

; Индексы (номера) задач.
			.equ TS_Idle 			= 0		 
			.equ TS_ScanADC		 	= 1		 
			.equ TS_Send 			= 2		 
			.equ TS_Fill	 		= 3		 
			.equ TS_Draw	 		= 4		
			.equ TS_SetDefMode		= 5		
			.equ TS_CheckADC	 	= 6		 
			.equ TS_Convert	 		= 7		
			.equ TS_ScanButton		= 8		
			.equ TS_Terminal 		= 9
			.equ TS_PWM_Light		= 10
			.equ TS_PWM_Light2		= 11		

; А это их адреса во флеше. ПО индексу вычисляется смещение в таблице адресов и происходит 
; Переход к задаче
TaskProcs: 	.dw Idle				; [00] 
			.dw ScanADC				; [01] 
			.dw Send				; [02] 
			.dw Fill				; [03] 
			.dw Draw 				; [04] 
			.dw SetDefMode			; [05] 
			.dw CheckADC			; [06] 
			.dw Convert				; [07] 
			.dw ScanButton			; [08]
			.dw	Terminal			; [09]
			.dw PWM_Light
			.dw PWM_Light2


; Подключены библиотеки работы с дисплеем и преобразования всякие
			.include "WH\lcd4.asm"
			.include "Math\hex2ascii.asm"
			

; Тексты режимов работы. Те что по английски пишутся как есть, а те которые по русски - кодами
; символов. Т.к. кодовая таблица HD44780 и ASCII в русском языке не совпадают.
t_Normal1:		.db	"YO OLOLO        "
t_Normal2:		.db "MAZAFAKA  RYZHIY"

t_Terminal:		.db	66,179,111,227,32,99,32,191,101,112,188,184,189,97,187,97

t_Button1:		.db 72,97,182,97,191,97,32,186,189,111,190,186,97,32,32,32
t_Button2:		.db 45,72,111,188,101,112,32,186,189,111,190,186,184,32,32,0

t_ADC1:			.db 65,225,168,44,32,186,97,189,97,187,32,48,32,32,32,32
t_ADC2:			.db 32,45,32,164,189,97,192,101,189,184,101,32,32,32
